// server.js
require('dotenv').config();

const express = require("express");
const mongoose = require("mongoose");
const routes = require('./routes');
const cors = require('cors');
const bodyParser = require('body-parser');
const cookieParser = require('cookie-parser');
const { createServer } = require('http');
const { Server } = require('socket.io');

const { createPaymentIntent } = require('./services/PaymentService');

const app = express();
const server = createServer(app);
const port = process.env.PORT || 3001;

// ‚úÖ CORS config linh ho·∫°t cho c·∫£ localhost v√† production
const allowedOrigins = [
  'http://localhost:3000',
  'https://fontend-doan.vercel.app',
  process.env.FRONTEND_URL // Th√™m bi·∫øn m√¥i tr∆∞·ªùng cho frontend URL
].filter(Boolean); // Lo·∫°i b·ªè c√°c gi√° tr·ªã undefined

// CORS cho Express
app.use(cors({
  origin: function (origin, callback) {
    // Cho ph√©p requests kh√¥ng c√≥ origin (nh∆∞ Postman, mobile apps, server-side requests)
    if (!origin) return callback(null, true);

    // Ki·ªÉm tra origin c√≥ trong danh s√°ch allowed kh√¥ng
    if (allowedOrigins.some(allowedOrigin =>
      origin === allowedOrigin ||
      origin.startsWith(allowedOrigin.replace('https://', 'http://')) ||
      (process.env.NODE_ENV === 'development' && origin.includes('localhost'))
    )) {
      return callback(null, true);
    }

    const msg = `CORS policy: Origin ${origin} not allowed`;
    console.warn('‚ö†Ô∏è CORS blocked:', msg);
    return callback(new Error(msg), false);
  },
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization', 'X-Requested-With', 'Cookie']
}));

// CORS cho Socket.io
const io = new Server(server, {
  cors: {
    origin: function (origin, callback) {
      if (!origin) return callback(null, true);
      if (allowedOrigins.some(allowedOrigin =>
        origin === allowedOrigin ||
        (process.env.NODE_ENV === 'development' && origin.includes('localhost'))
      )) {
        return callback(null, true);
      }
      return callback(new Error('Not allowed by CORS'), false);
    },
    methods: ['GET', 'POST'],
    credentials: true
  },
  transports: ['websocket', 'polling'] // H·ªó tr·ª£ c·∫£ hai lo·∫°i transport
});

// Middleware
app.use(bodyParser.json({ limit: '10mb' }));
app.use(bodyParser.urlencoded({ limit: '10mb', extended: true }));
app.use(cookieParser());

// Health check endpoint
app.get('/health', (req, res) => {
  res.status(200).json({
    status: 'OK',
    message: 'Server is running',
    timestamp: new Date().toISOString(),
    environment: process.env.NODE_ENV || 'development'
  });
});

// Routes
routes(app);

// Test Stripe route
app.post('/test-payment', async (req, res) => {
  if (!process.env.STRIPE_SECRET_KEY) {
    return res.status(500).json({
      status: 'ERR',
      message: 'STRIPE_SECRET_KEY ch∆∞a ƒë∆∞·ª£c thi·∫øt l·∫≠p',
    });
  }

  const { totalPrice } = req.body || { totalPrice: 100000 };
  const result = await createPaymentIntent(totalPrice);
  res.json(result);
});

// Socket.io logic
const onlineUsers = new Map();

io.on('connection', (socket) => {
  console.log('üîó User connected:', socket.id, 'from:', socket.handshake.headers.origin);

  // Th√™m user v√†o danh s√°ch online
  socket.on('addUser', (userId, userData) => {
    onlineUsers.set(userId, {
      socketId: socket.id,
      ...userData
    });
    console.log('üë• Online users:', Array.from(onlineUsers.keys()));
    io.emit('getOnlineUsers', Array.from(onlineUsers.values()));
  });

  // G·ª≠i tin nh·∫Øn
  socket.on('sendMessage', async (messageData) => {
    try {
      console.log('üì® New message received:', messageData);

      const ChatService = require('./services/ChatService');
      const savedMessage = await ChatService.saveMessage(messageData);

      console.log('üíæ Message saved:', savedMessage._id);

      // === X·ª≠ l√Ω g·ª≠i tin nh·∫Øn ===
      if (messageData.receiverId === 'admin') {
        // User g·ª≠i ‚Üí t√¨m admin trong onlineUsers (Map)
        let adminFound = false;
        for (let [userId, userInfo] of onlineUsers) {
          if (userInfo.role === 'admin') {
            io.to(userInfo.socketId).emit('receiveMessage', savedMessage);
            console.log('üì§ Sent to admin:', userId);
            adminFound = true;
          }
        }
        if (!adminFound) {
          console.log('‚ö†Ô∏è No admin online, message stored only.');
        }
      } else {
        // Admin g·ª≠i ‚Üí t√¨m user c·ª• th·ªÉ
        const userReceiver = onlineUsers.get(messageData.receiverId);
        if (userReceiver) {
          io.to(userReceiver.socketId).emit('receiveMessage', savedMessage);
          console.log('üì§ Sent to user:', messageData.receiverId);
        } else {
          console.log('‚ö†Ô∏è User not online, message stored only.');
        }
      }

      // G·ª≠i x√°c nh·∫≠n cho ng∆∞·ªùi g·ª≠i
      socket.emit('messageSent', {
        status: 'success',
        messageId: savedMessage._id,
        message: savedMessage
      });

      // === C·∫≠p nh·∫≠t danh s√°ch conversation cho admin ===
      const { Conversation } = require('./models/ChatModel');
      const conversations = await Conversation.find({ isActive: true })
        .sort({ lastMessageTime: -1 });

      // G·ª≠i update ƒë·∫øn t·∫•t c·∫£ admin
      for (let [userId, userInfo] of onlineUsers) {
        if (userInfo.role === 'admin') {
          io.to(userInfo.socketId).emit('conversationsList', conversations);
          console.log('üîÑ Sent updated conversations to admin:', userId);
        }
      }

    } catch (error) {
      console.error('‚ùå Error sending message:', error);
      socket.emit('messageError', { error: error.message });
    }
  });

  // L·∫•y l·ªãch s·ª≠ chat
  socket.on('getChatHistory', async (userId) => {
    try {
      const ChatService = require('./services/ChatService');
      const messages = await ChatService.getMessages(userId, 'admin');
      socket.emit('chatHistory', messages);
      console.log('üìö Sent chat history for user:', userId, 'Messages:', messages.length);
    } catch (error) {
      console.error('‚ùå Error getting chat history:', error);
      socket.emit('chatHistoryError', { error: error.message });
    }
  });

  // L·∫•y conversations cho admin
  socket.on('getConversations', async () => {
    try {
      const { Conversation } = require('./models/ChatModel');
      const conversations = await Conversation.find({ isActive: true })
        .sort({ lastMessageTime: -1 })
        .populate('userId', 'name email avatar');

      console.log('üìû Sending conversations:', conversations.length);
      socket.emit('conversationsList', conversations);
    } catch (error) {
      console.error('‚ùå Error getting conversations:', error);
      socket.emit('conversationsError', { error: error.message });
    }
  });

  // ƒê√°nh d·∫•u tin nh·∫Øn ƒë√£ ƒë·ªçc
  socket.on('markMessagesAsRead', async (userId) => {
    try {
      console.log('üìñ Marking messages as read for user:', userId);
      const ChatService = require('./services/ChatService');

      // ƒê√°nh d·∫•u tin nh·∫Øn ƒë√£ ƒë·ªçc
      await ChatService.markMessagesAsRead(userId);

      // C·∫≠p nh·∫≠t unread count
      await ChatService.updateConversationUnreadCount(userId);

      // G·ª≠i confirmation
      socket.emit('messagesRead', { userId, success: true });

      // C·∫≠p nh·∫≠t danh s√°ch conversations
      const { Conversation } = require('./models/ChatModel');
      const conversations = await Conversation.find({ isActive: true })
        .sort({ lastMessageTime: -1 })
        .populate('userId', 'name email avatar');

      socket.emit('conversationsList', conversations);

    } catch (error) {
      console.error('‚ùå Error marking messages as read:', error);
      socket.emit('messagesReadError', { error: error.message });
    }
  });

  // ƒê√°nh d·∫•u t·∫•t c·∫£ tin nh·∫Øn ƒë√£ ƒë·ªçc
  socket.on('markAllMessagesAsRead', async () => {
    try {
      console.log('üìñ Marking ALL messages as read');
      const ChatService = require('./services/ChatService');
      const { Conversation } = require('./models/ChatModel');

      // L·∫•y t·∫•t c·∫£ conversations
      const conversations = await Conversation.find({ isActive: true });

      // ƒê√°nh d·∫•u t·∫•t c·∫£ tin nh·∫Øn l√† ƒë√£ ƒë·ªçc
      for (const conversation of conversations) {
        await ChatService.markMessagesAsRead(conversation.userId);
        await ChatService.updateConversationUnreadCount(conversation.userId);
      }

      socket.emit('allMessagesRead', { success: true });
      socket.emit('conversationsUpdated');

    } catch (error) {
      console.error('‚ùå Error marking all messages as read:', error);
      socket.emit('messagesReadError', { error: error.message });
    }
  });

  // Ng·∫Øt k·∫øt n·ªëi
  socket.on('disconnect', () => {
    console.log('üî¥ User disconnected:', socket.id);

    for (let [userId, user] of onlineUsers.entries()) {
      if (user.socketId === socket.id) {
        onlineUsers.delete(userId);
        console.log('üóëÔ∏è Removed user from online list:', userId);
        break;
      }
    }

    io.emit('getOnlineUsers', Array.from(onlineUsers.values()));
  });

  socket.on('error', (error) => {
    console.error('üí• Socket error:', error);
  });
});

// Connect DB v·ªõi config linh ho·∫°t
const connectDB = async () => {
  try {
    const mongoURI = process.env.MONGO_DB;
    if (!mongoURI) {
      throw new Error('MONGO_DB environment variable is not defined');
    }

    await mongoose.connect(mongoURI, {
      useNewUrlParser: true,
      useUnifiedTopology: true,
    });
    console.log('‚úÖ Connect DB success');
  } catch (err) {
    console.log('‚ùå DB connection error:', err);
    // Th·ª≠ k·∫øt n·ªëi l·∫°i sau 5 gi√¢y
    setTimeout(connectDB, 5000);
  }
};

connectDB();

// Check Stripe key
if (!process.env.STRIPE_SECRET_KEY) {
  console.warn('‚ö†Ô∏è C·∫¢NH B√ÅO: STRIPE_SECRET_KEY ch∆∞a ƒë∆∞·ª£c thi·∫øt l·∫≠p!');
} else {
  console.log('‚úÖ STRIPE_SECRET_KEY ƒë√£ load th√†nh c√¥ng.');
}

// X·ª≠ l√Ω l·ªói to√†n c·ª•c
process.on('unhandledRejection', (err) => {
  console.error('üí• Unhandled Promise Rejection:', err);
});

process.on('uncaughtException', (err) => {
  console.error('üí• Uncaught Exception:', err);
  process.exit(1);
});

// Run server
server.listen(port, () => {
  console.log(`üöÄ Server is running on port ${port}`);
  console.log(`üåç Environment: ${process.env.NODE_ENV || 'development'}`);
  console.log(`üí¨ Socket.io is ready for connections`);
  console.log(`‚úÖ Allowed origins:`, allowedOrigins);
});

module.exports = { app, io, server };